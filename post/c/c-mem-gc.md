# GC
## 引用计数垃圾收集
最简单的垃圾收集算法
### 限制：循环引用
该算法有个限制：无法处理循环引用。
1. o1, o2 在函数销毁后，计数从2变1
2. 计数1：o1,o2 相互引用，相互需要。但是实际不被别人需要
3. 改进-循环检测：
    1. 从`o1 = o2.a <- o2 = o1.a <- o1` 发生循环`o1=o2.a减一` 变零`销毁o1`，
    2. `销毁o1`-`销毁o1.a` 导致`o2`减去1， `o2`被销毁

recycle counter:

    function f(){
        var o1 = {};
        var o2 = {};
        o1.a = o2; // o1 引用 o2
        o2.a = o1; // o2 引用 o1
    }

    f();

## 标记-清除算法
这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。

这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。