<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
<title>Ahuigo 的网络日志</title>
<link href="https://ahuigo.github.io/atom.xml" rel="self" type="application/atom+xml"/>
<updated>2018-08-17T13:46:49Z</updated>
<subtitle>ahuigo's Blog</subtitle>
<entry xml:base="https://ahuigo.github.io/">
<title>python3 的struct 字节处理工具</title>
<link href="#/post/py/py-str-struct.md" rel="alternate" type="text/html"/>
<author>
<name>ahuigo</name>
<uri>https://ahuigo.github.io</uri>
</author>
<published>2018-05-05T00:00:00Z</published>
<updated>2018-08-17T13:46:49Z</updated>
<summary/>
<content>1. 而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。
2. Python3 中处理bytes 字节也很方便，同时还提供了强大的struct 处理工具

# 一般的字节处理
在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写：

	&gt;&gt;&gt; n = 10240099
	&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24
	&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16
	&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8
	&gt;&gt;&gt; b4 = n &amp; 0xff
	&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])
	&gt;&gt;&gt; bs
	b'\x00\x9c@c'

非常麻烦。如果换成浮点数就无能为力了。

好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。

## buffer
int to bytes： like js Buffer.from([1,2,3])

	&gt;&gt;&gt; bytes([0, 1, 97])
	b'\x00\x01a'

### str2hex

    'abc'.encode().hex()
        '616263'
    bytes.fromhex('6162')
        b'abc'

int to strhex

    &gt;&gt;&gt; hex(16)
    '0x10'

see: py/py-strack for unpack

## base64

    import base64
    &gt;&gt;&gt; base64.b64encode(b'a')
    b'YQ=='
    &gt;&gt;&gt; base64.b64decode(b'a')

# struct

## pack
struct的pack函数把任意数据类型变成bytes：

	&gt;&gt;&gt; import struct
	&gt;&gt;&gt; struct.pack('&gt;I', 8) # big-endian
    b'\x00\x00\x00\x08'
	&gt;&gt;&gt; struct.pack('&lt;I', 8) # big-endian
    b'\x08\x00\x00\x00'

pack的第一个参数是处理指令，`&gt;I`的意思是：

	&gt; 表示字节顺序是big-endian，也就是网络序，
	I 表示4字节无符号整数。

后面的参数个数要和处理指令一致。

## unpack
unpack把bytes变成相应的数据类型：

	&gt;&gt;&gt; struct.unpack('&gt;IH', b'\xf0\xf0\xf0\xf0\x80\x80')
	(4042322160, 32896)

根据`&gt;IH`的说明，后面的bytes依次变为:

    c	char
    b	signed char	    B	unsigned char
    h: 2 bytes integer  H：2字节无符号整数。
	i: 4bytes integer   I：4字节无符号整数和
    l: 8bytes           L: 8 byte unsigned

所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。

struct模块定义的数据类型可以参考Python官方文档：

https://docs.python.org/3/library/struct.html#format-characters

## bmp
Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。

首先找一个bmp文件，没有的话用“画图”画一个。

读入前30个字节来分析：

	&gt;&gt;&gt; s = b'\x42\x4d\x38\x8c\x0a\x00\x00\x00\x00\x00\x36\x00\x00\x00\x28\x00\x00\x00\x80\x02\x00\x00\x68\x01\x00\x00\x01\x00\x18\x00'

BMP格式采用小端方式存储数据，文件头的结构按顺序如下：

1. 两个字节：'BM'表示Windows位图，'BA'表示OS/2位图；
1. 一个4字节整数：表示位图大小；
1. 一个4字节整数：保留位，始终为0；
1. 一个4字节整数：实际图像的偏移量；
1. 一个4字节整数：Header的字节数；
1. 一个4字节整数：图像宽度；
1. 一个4字节整数：图像高度；
1. 一个2字节整数：始终为1；
1. 一个2字节整数：颜色数。

所以，组合起来用unpack读取：

	&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH', s)
	(b'B', b'M', 691256, 0, 54, 40, 640, 360, 1, 24)

结果显示，b'B'、b'M'说明是Windows位图，位图大小为640x360，颜色数为24。
</content>
</entry><entry xml:base="https://ahuigo.github.io/">
<title> ES6 Modudle 使用</title>
<link href="#/post/ria/js-module.md" rel="alternate" type="text/html"/>
<author>
<name>ahuigo</name>
<uri>https://ahuigo.github.io</uri>
</author>
<published>2018-04-05T00:00:00Z</published>
<updated>2018-08-17T13:46:49Z</updated>
<summary/>
<content>Module: don't use globals in my applications.

    // es5
    ROOT_DIR=__dirname;  // 不要用 const, var(es5)

    // es6
    (global||window).ROOT_DIR=__dirname;

    // module.js
    let users = require(ROOT_DIR+'/conf/users')
    let users = require(global.ROOT_DIR+'/conf/users')
    let users = require('../conf/users')

## module storage
ES6 recommend import global module:

    //a.js
    require('./config')['name']='ahui'
    //b.js
    require('./config')['name']==='ahui'

in webpack, use definePlugin to config new consants:

    /* Webpack configuration */
    const webpack = require('webpack');
    new webpack.DefinePlugin({
        'VALUE_1': 123,
        'VALUE_2': 'abc'
    });

    /* SomeComponent.js */
    if (VALUE_1 === 123) {
        // do something
    }

## module this
module `this` is `{}`, not `global===window`

# Es6 module
- export 定义值
- import 引入

## export
profile.js

    // 写法一
    export var m = 1;

    // 写法二
    var m = 1;
    export {m};

    // 写法三
    var n = 1;
    export {n as m};

变量foo，值为bar，500 毫秒之后变成baz。

    export var foo = 'bar';
    setTimeout(() =&gt; foo = 'baz', 500);

这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新

## import 
1. import vs node require: https://cnodejs.org/topic/5a0f2da5f9de6bb0542f090b
2. 默认只能是`*.mjs`，通过Loader Hooks可以自定义配置规则支持`*.js,*.json`等Node原有支持文件
    1. node --experimental-modules ./index.mjs

    // ES6模块
    import 'fs';
    import {stat} from 'fs';
    import { stat as st, exists, readFile } from 'fs';

    import A from './a?v=2017'
        ./a.js
        a.js
        a

profile.js

    export var foo = 'bar';
    export var area = 'China';

main.js(babel)

    import {foo} from './profile.js';
    import {foo} from './profile';
    import * from './profile';
    import * from 'profile';
    import * as profile from './profile';

注意，`export *` 命令会忽略模块的default方法

## export default 命令
因为export default命令的本质是将后面的值，赋给default变量，所以它后面不能跟变量声明语句

    // 正确
    var a = 1;
    export default a;
    export default 42;

    // 错误
    export default var a = 1;

default 与其他变量混用

    import _, { each, each as forEach } from 'lodash';

## export *
    // lib/mathplusplus.js
    export * from "lib/math";
    export var e = 2.71828182846;
    export default function(x) {
        return Math.exp(x);
    }
    // app.js
    import exp, {pi, e} from "lib/mathplusplus";
    console.log("e^π = " + exp(pi));

## export 与 import 的复合写法 

    export { foo, bar } from 'my_module';

    // 可以简单理解为
    import { foo, bar } from 'my_module';
    export { foo, bar };

    export * from 'my_module';
    export { es6 as default } from './someModule';


# Node: commonJS
## Create module
hello module: hello.js

    //暴露变量
    module.exports = {
        hello: hello,
        greet: greet
    };
    exports.hello = hello;
    exports.greet = greet;

## 加载模块

    // 引入./hello.js模块,
    var s = 'Hello';
    var greet = require('./hello');
    greet('Michael'); // Hello, Michael!

如果没有`.`或者`绝对路劲`, Node会依次在内置模块、全局模块和当前模块下查找hello.js, 但是不会在当前目录查找

    var greet = require('hello');

# Package, 打包
http://www.ruanyifeng.com/blog/2014/09/package-management.html

old:
- Bower - 不打包，只是install/update..: YeoMan和Grunt 建立在Bower基础之上
    　　# 模块的名称
    　　$ bower install jquery
    　　# github用户名/项目名
    　　$ bower install jquery/jquery
- Browserify - 将多个require('js') 合并
    - browserify robot.js &gt; bundle.js
- dao: package both js/css
- Gulp: 一个新的基于流的`管道式构建工具`，用于代替过时的Grunt。 类似于java 的Maven
    - http://javascript.ruanyifeng.com/tool/gulp.html
    - https://segmentfault.com/a/1190000002491282

new:
- webpack: 静态模块打包器(module bundler): js/css/png/font/..., 整合了gulp的优
- parcel: 比较webpack 属于0配置，专注也web，不能用于打包npm
- rollup: Facebook出品的es2015 Rollup 是下一代的 javascript 打包器，它使用 tree-shaking 的技术使打包的结果只包括实际用到的 exports。 使用它打包的代码，基本没有冗余的代码，减少了很多的代码体积
    1. https://w3ctech.com/topic/1996
    2. http://www.rollupjs.com

## dao
将js/css 合并

    $ cat index.css
    @import 'necolas/normalize.css';
    @import './layout/layout.css';
　　
　　 body {
　　  color: teal;
　　  background: url('./background-image.jpg');
　　 }
    
    $ duo index.css &gt; build.css
</content>
</entry><entry xml:base="https://ahuigo.github.io/">
<title>Js Array </title>
<link href="#/post/ria/js-array.md" rel="alternate" type="text/html"/>
<author>
<name>ahuigo</name>
<uri>https://ahuigo.github.io</uri>
</author>
<published>2018-08-16T17:22:32Z</published>
<updated>2018-08-16T17:22:32Z</updated>
<summary/>
<content/>
</entry></feed>